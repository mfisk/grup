#!/usr/local/bin/perl
#Program: grup
#Author: Michael Fisk
#Date: 10-13-94, last modified 7-27-95
#Language: Perl
#Version: 2.1
# $Id$

#Expand a YP netgroup, recursively, and apply a command to all machines in it

$DefaultCmd = "ping %mx 1";
$MAXPROCS = 15;

if (! @ARGV) {
    print <<EOM;
Usage: $0 [-Option] [[-h hostname] ...] [netgroup] [-ExecOption commands]

Valid "Options" are as follows.  
Only enough of the option name to make it unamiguous is required:
\t-fail   \tonly show output from commands that fail
\t-first  \tshows the first up machine that returns
\t-fork   \tfork each command instead of running them sequentially
\t-hostname\tspecifies a hostname to use
\t-noheader\tdon't print "Checking:" header
\t-nosummary\tdon't print final summary
\t-quiet  \tonly returns the output from the child processes
\t-summary\tonly returns summary information 
\t-succeed\tonly show output from commands that succeed

The following "ExecOptions" must be after the netgroup and/or hostnames:
\t-e[xec]   \texecutes an sh command for each machine with any
\t\t\treference of %mx translated to the remote machine name
\t-r[sh]    \tis the same as -e with "rsh %mx" prepended
\t-p[erl]   \tis the same as -e but the command is evaluated as Perl 

\tThe default command if no -e is given is:\tping %mx 1
EOM
    exit;
}

$Header = 1;
$Summary = 1;
while($_ = shift) {
    if (/^-fi/) {
	$First = 1; $Header = 0; $Summary = 0;
    } elsif (/^-fa/) {
	$FailsOnly = 1;
    } elsif (/^-f/) {
	$DoFork = 1;
    } elsif (/^-e/) {
	$ExecCmd = join(" ",@ARGV);
	@ARGV = ();
    } elsif (/^-r/) {
	$ExecCmd = "rsh %mx " . join(" ",@ARGV);
	@ARGV = ();
    } elsif (/^-p/) {
	$PerlCmd = 1;
	$ExecCmd = join(" ",@ARGV);
	@ARGV = ();
    } elsif (/^-noh/) {
	$Header = 0;
    } elsif (/^-nos/) {
	$Summary = 0;
    } elsif (/^-h/) {
	push(@mxlist,shift);
    } elsif (/^-q/) {
        $quiet = 1; $Header = 0; $Summary = 0;
    } elsif (/^-suc/) {
	$SuccessOnly = 1;
    } elsif (/^-s/) {
	$SummaryOnly = 1;
	$quiet = 1;
    } elsif (/^-/) {
	print stderr "Unknown or ambiguous option `$_'!\n";
    } else {
	unshift(@groups,$_);
    }
}


#Parse a netgroup
while ($group=shift(@groups)) {
    $yplist = `ypmatch $group netgroup`;
    @list = split(/\s+/,$yplist);
    foreach $mx (@list) {
	if ($mx =~ /^\(/) {
	    $mx = (split(/[\(,]/,$mx))[1];
	    if ( $mx ) { push(@mxlist,$mx); }
	} else {
	    push(@groups,$mx);
	}
    }	
}

if (! @mxlist) { 
    print "No machines in netgroup \"$group\"\n"; 
    exit; 
}
print "Checking: @mxlist\n\n" if $Header;


$upcount = $downcount = 0;

if ($DoFork) {
    while ($mx = shift(@mxlist)) {
	unshift(@smallist,$mx);
	if ($#smallist == $MAXPROCS) {
	    &CheckGroup(@smallist);
	    @smallist = ();
	}
    }
    &CheckGroup(@smallist);
} else {
    &CheckGroup(@mxlist);
}

exit if ! $Summary;
 
print "\n$upcount Succeeded; $downcount Failed; ";
print $#mxlist+1 . " Machines\n";
exit;

sub DoCmd {
    local($mx) = shift;
    local($execcmd);
    local($ping);
    local($exit) = 0;

    $execcmd = $ExecCmd || $DefaultCmd;
    $execcmd =~ s|%mx|$mx|g;
    if ($PerlCmd) {
	print "$mx:\t" unless $quiet;
	$exit = ! eval $execcmd;
	print "\n";
    } else { 
	$ping = `$execcmd 2>&1`;
	$exit = $? >> 8;
	if (! $ExecCmd) {
	    $ping =~ s|$mx||g;
	    $ping =~ s|is ||g;
	    $ping =~ s|from ||g;
	}
	if (($FailsOnly && $?) || ($SuccessOnly && !$?) ||
	    (! ($FailsOnly || $SuccessOnly))) {
	    print "$mx:\t" unless $quiet;
	    print $ping unless $SummaryOnly;
	}
    }
    return $exit;
}

sub CheckGroup {
    local(@mxlist) = @_;
    local($notdone);

    $notdone = $#mxlist+1;
    @pids = ();
    $mxnum = 0;

#Spawn a process to check each machine
    foreach $mx (@mxlist) {
	if ($DoFork) {
	    $pids[$mxnum] = fork;	
	    {
		if ($pids[$mxnum] >= 0) { # Successful fork
		    if (! $pids[$mxnum]) { # Child
			exit(&DoCmd($mx));
		    }		       
		} else {		# Unsuccessful fork
		    warn "Retrying $mx: fork: $!\n";
		    sleep 3;
		    redo;
		}
	    }
	    $mxnum++;
	} else {
	    if (! &DoCmd($mx)) {
		$upcount++;
		exit if $First;
	    } else {
		$downcount++;
	    }
	}
    }			      

    return unless $DoFork;

#Check output of child processes
    while ( $notdone ) {
	for ($i=0; $i <= $#mxlist; $i++) {
	    if ( @pids[$i] ) {
		$wp = waitpid(@pids[$i],1);
		if ( $wp > 0 ) { 
		    $? = $? >> 8;
		    if (! $? ) {
			$upcount++;
		    } else {
			$downcount++;
		    }
		    @pids[$i] = 0;
		    $notdone--;
		}
	    }
	}
    }
}




